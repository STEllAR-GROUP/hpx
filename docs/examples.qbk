[/=============================================================================
Copyright (C) 2012 Adrian Serio
Copyright (C) 2012 Vinay C Amatya

Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section:examples Examples]

Here are some more examples for our reader to get more familiar with HPX style
programming.

[/////////////////////////////////////////////////////////////////////////////]
[section:fibonacci Fibonacci]

The Fibonacci sequence is a sequence of numbers starting with 0 and 1 where
every subsequent number is the sum of the previous two numbers. In this example
we will use HPX to calculate the value of the n-th postition of the Fibonacci
sequece. In order to compute this problem in parallel, we will use a tool known
as a future. Futures are packets of work that are sent to woker nodes that 
at a later time can be called by the internal function '.get()' to return 
their values. This allows HPX to schedule work early in a program so that 
later when the funtion value is needed it will be avalable.

[heading Setup]

The source code for this exaple in in the SVN repository:
[^parallex/hpx/examples/quickstart/fibonacci.cpp]
[fixme Add link to source here].

To compile this file type:
  
  make examples.quickstart.fibonacci

If you know how many cores your machine has use make's '-j' option to increase
the number of parallel pocesses that are runing. You should start your number
of cores plus an additional process for maximum speed. For instance, if your
machine has 4 cores you would type:

  make examples.quickstart.fibonacci -j5

for the fastset build.

To run the program type:

  ./bin/fibonacci

This should print (time should be approxamate):

  fibonacci(10) == 55
  elapsed time: 0.00186288 [s]

This run used the default setting of calculating the tenth place of the
Fibonacci sequence. To declare which position you want to calculate, use
the '--n-value' option. Addtitionally you can use the '--hpx:threads' option
to declare how many threads you wish to use when running the program. For 
instance,running:

  ./bin/fibonacci --n-value 20 --hpx:threads 5

Will yeild:

  fibonacci(20) == 6765
  elapsed time: 0.233827 [s]

[heading Walk-through]

Now that you can compile and run the code lets look at how the code works. 
Since this code is written in C++ we will begin with main. Here you can
see that in HPX main is only used to initialize the runtime system. It is 
important to note that command line options are defined here. You can see
below that our programs '--n-value' is set by the instance of the Boost 
library class [^options_description] using the public member function 
[^.add_options()] (to learn more about this class see the __boost_doc__).
In the desctription, the defalut value of
the variable is set to 10. This is why when we ran the program for the first
time without using the '--n-value' option the program returned the 10th
value of the Fibonacci sequence. The last part of the description is the
text that appears when a user uses the '--help' option to see what command
line options are avalable.

[import ../examples/quickstart/fibonacci.cpp]
[fib_main]

The [^init()] function in main calls hxp_main which is where the ["meat] of the
program is. Below we can see that the basic program is simple. The command
line option 'n-value' is read in, a timer is set, two functions are called,
and the data is printed out. 

[fib_hpx_main]

Upon a closer look we see that the first of 
the two functions is of type [^fibonacci_future]. This was defined earlier
in the code:

[fib_typedef]

But wait, [^eager_future] is a type but what is [^fibonacci_action]? Again
we turn to the code and find this section right before [^fibonacci_future]
was typedefined:

[fib_action]

Finally we are getting somewhere! In this block of code the function 
[^fibonacci] is declared. After the declaration, the function was wrapped in
an action called [^plain_result_action1] (we use [^plain_result_action1]
because the function takes one argument). This action was then ["registered]
as an HPX action.

This picture should now start making sense. The function [^fibonacci] is
wrapped in an action [^plain_result_action1], which in turn was wrapped
in a future [^eager_future]. Now that we understand where all these variables
are comming from lets look at the function [^fibanacci]:

[fib_func]

On first inspection this block of code is straight forward. First if n < 2,
meaning if n = 0 or 1, then return 0 or 1 (as we recall the first position 
of the Fibanacci sequence is 0 and the second is one). Next call
[^fibonacci_future] twice and subtract n before it is passed to the function. 
Finaly get the values of the futures and return their sum. But hold-the-phone
by calling [^fibonacci_future] we are calling the function recursively! This 
is where the power of futures is displayed. [^fibonacci_future] will continue
to be called until the value of n = 0 or 1 (it increments down each time
the function is called) at which point the values of the futures will be
returned by [^get()] and the value of the n-th position of the Fibonacci
sequence will be calculated.

[endsect] [/Fibonacci]

[/////////////////////////////////////////////////////////////////////////////]
[section:hello_world Hello World v2]

You have already looked at a simple ["Hello World] example.  In this version
each locality will print out a statement that says which OS thread executed it
and which locality it came from.  The output will look something like this:

    hello world from OS-thread 2 on locality 0
    hello world from OS-thread 5 on locality 2
    hello world from OS-thread 0 on locality 0

[heading Setup]

The source file is already created for you and could be found in the svn
repository: [^parallex/hpx/examples/quickstart/hello_world.cpp]
[fixme add a link here].

To compile this file type:

    make examples.quickstart.hello_world

To run the program type:

    ./bin/hello_world

This should print:

    hello world from OS-thread 0 on locality 0

To include more threads use the command line option '--hpx:threads' and 
type the number of threads that you wish to use.  For example, typing:

    ./bin/hello_world --hpx:threads 2

will yield:

    hello world from OS-thread 1 on locality 0
    hello world from OS-thread 0 on locality 0

Notice how the ordering of the two print statements will change with
subsequent runs.
[fixme explain how to run hello world on multiple localites]

[heading Walk-through]

Now that you can complile and run the code lets look at how the code works
begining with main:

[import ../examples/quickstart/hello_world.cpp]
[hello_world_main]
[hello_world_hpx_main]

In this excerpt of the code there are alot of new concepts such as
["promise] which require explanation.  HPX is an ["action oriented] runtime
system, which means that the information shared between compute nodes is in
the form of ["work] or processes to be done.  This work is passed to other
nodes in containers such as a ["promise].  For these work-containers to
function properly, however, they must be wrapped in another device called
an ["action].  We do this by declaring this:

[hello_world_action_wrapper]

Another way of thinking about this technique is as follows: functions 
(the work to be done) are wrapped in promises which are wrapped in 
actions which are distributed to compute nodes.

Now it is time to look at the [^hellow_world_foreman] which was wrapped in
the action above:

[hello_world_foreman]

Here the set 'attendance' is keeping track of which localities have printed
out the hello world statement. When the locality prints out the statement
the future returns to wait which invokes the lambda funtion '&'.  This 
funtion '&' erases the thread from the set 'attendance' thus letting 
[^hello_world_forman] know how many localites still needed to print out
["hello world]. However, if the future returns a value of -1 the thread is
skipped and that thread remains in 'attendance' for another cycle of the 
while loop.

Finally, let us look at [^hello_world_worker].  Here [^hello_world_woker]
checks to see if it is on the target locality. If it is the correct locality,
it prints out the hello world statement and returns the OS thread number
to [^wait()] in [^hello_world_forman].  If it is not the correct locality,
it returns a value of -1 which when returned to [^hello_world_forman]
leaves that locality's thread number in the set 'attendance'.

[hello_world_worker]

[endsect] [/Hello World]

[/////////////////////////////////////////////////////////////////////////////]
[section:accumulator Accumulator]

Accumulator is a simple example that exposes the notion of components in HPX.
Components allow us to run applicationin in distributed environment in HPX.
This example exposes four differenct functions: init, add, query and print.
What this example does is it takes an input from a client locality component,
puts value in a data type (unsigned long) at the remote locality component.
Print command at the client would print the contents of the remote locality
component at the remote locality. Query command at the client would print the
contents of the remote locality component at client locality.

[heading Building the example]

From your build directory, type the following:

    make examples.accumulator.accumulator

[heading Run the example]

From your bin directory inside install path, type the following:

[teletype][/ switch to plain text source mode]
On single machine, first console:

    ./accumulator_client -0 -l2

Same machine, second console, on identical path as above: [teletype]

    ./accumulator_client -1 -l2

[heading Results]

Console 1:

    accumulator client, you may enter some commands (try 'help' if in doubt...)
    add 5
    print
    query
    {0000000200ff0001, 000000000002ffff}> 5
    print
    add 5
    print
    query
    {0000000200ff0001, 000000000002ffff}> 10
    quit

Console 2:

    {0000000200000000, 00007fff21db4860}> 5
    {0000000200000000, 00007fff21db4860}> 5
    {0000000200000000, 00007fff21db4860}> 10

[c++][/ switch back to C++ source mode]

[endsect] [/Accumulator]
[/////////////////////////////////////////////////////////////////////////////]

[endsect] [/Examples]
