[/=============================================================================
    Copyright (C) 2007-2013 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section:cmake Building __hpx__ with CMake]

The buildsystem for __hpx__ is based on __cmake__. CMake is a cross-platform
build-generator tool. CMake does not build the project, it generates the files
needed by your build tool (GNU make, Visual Studio, etc) for building __hpx__.

[/////////////////////////////////////////////////////////////////////////////]
[section:introduction Introduction]

__cmake__ is a cross-platform build-generator tool. CMake does not build the
project, it generates the files needed by your build tool (GNU make, Visual
Studio, etc) for building __hpx__.

If you are really anxious about getting a functional __hpx__ build, go to the
__cmake_quick_start__ section. If you are a CMake novice, start on 
__cmake_basic_usage__ and then go back to the __cmake_quick_start__ once you 
know what you are doing. The __cmake_options__ section is a reference for 
customizing your build. If you already have experience with CMake, this is the 
recommended starting point.

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:quick_start Quick Start]

[teletype]

We use here the command-line, non-interactive __cmake__ interface.

# Download and install CMake here: __cmake_download__. Version 2.8 is the
  minimally required version for __hpx__.

# Open a shell. Your development tools must be reachable from this shell through
  the PATH environment variable.

# Create a directory for containing the build. It is not supported to build
  __hpx__ on the source directory. cd to this directory:
``
    $ mkdir mybuilddir
    $ cd mybuilddir
``

# Execute this command on the shell replacing path/to/hpx/ with the path to
  the root of your __hpx__ source tree:
``
    $ cmake path/to/hpx
``

CMake will detect your development environment, perform a series of tests and
will generate the files required for building __hpx__. CMake will use default 
values for all build parameters. See the __cmake_options__ section for 
fine-tuning your build.

This can fail if CMake can't detect your toolset, or if it thinks that the
environment is not sane enough. On this case make sure that the toolset that
you intend to use is the only one reachable from the shell and that the shell
itself is the correct one for you development environment. CMake will refuse to
build MinGW makefiles if you have a POSIX shell reachable through the PATH
environment variable, for instance. You can force CMake to use a given build
tool, see the __cmake_basic_usage__ section.

[c++]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:basic_usage Basic CMake Usage]

[teletype]

This section explains basic aspects of __cmake__, mostly for explaining those
options which you may need on your day-to-day usage.

CMake comes with extensive documentation in the form of html files and on the
cmake executable itself. Execute `cmake --help` for further help options.

CMake requires to know for which build tool it shall generate files (GNU make,
Visual Studio, Xcode, etc). If not specified on the command line, it tries to
guess it based on you environment. Once identified the build tool, CMake uses
the corresponding Generator for creating files for your build tool. You can
explicitly specify the generator with the command line option
`-G "Name of the generator"`. For knowing the available generators on your
platform, execute:
``
    $ cmake --help
``

This will list the generator names at the end of the help text. Generator names
are case-sensitive. Example:
``
    $ cmake -G "Visual Studio 9 2008" path/to/hpx
``

For a given development platform there can be more than one adequate generator.
If you use Visual Studio `"NMake Makefiles"` is a generator you can use for building
with NMake. By default, CMake chooses the more specific generator supported by
your development environment. If you want an alternative generator, you must tell
this to CMake with the `-G` option.

[c++]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:options Options and Variables]

[teletype]

Variables customize how the build will be generated. Options are boolean
variables, with possible values ON/OFF. Options and variables are defined on
the CMake command line like this:
``
    $ cmake -DVARIABLE=value path/to/hpx
``

You can set a variable after the initial CMake invocation for changing its
value. You can also undefine a variable:
``
    $ cmake -UVARIABLE path/to/hpx
``

Variables are stored on the CMake cache. This is a file named CMakeCache.txt on
the root of the build directory. Do not hand-edit it.

Variables are listed here appending its type after a colon. It is correct to
write the variable and the type on the CMake command line:
``
    $ cmake -DVARIABLE:TYPE=value path/to/llvm/source
``

CMake supports the following variable types: `BOOL` (options), `STRING`
(arbitrary string), `PATH` (directory name), `FILEPATH` (file name).

[c++]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:variables Frequently used CMake Variables]

Here are listed some of the CMake variables that are used often, along with a
brief explanation and __hpx__-specific notes. For full documentation, check the
CMake docs or execute `cmake --help-variable VARIABLE_NAME`.

[variablelist Frequently used CMake Variables
    [[`CMAKE_BUILD_TYPE:STRING`]
     [Sets the build type for make based generators. Possible values are
      `Release`, `Debug`, `RelWithDebInfo` and `MinSizeRel`. The default value
      for this variable is `Release`.]
    ]
    [[`CMAKE_INSTALL_PREFIX:PATH`]
     [Path where __hpx__ will be installed if `make install` is invoked or
      the `INSTALL` target is built. The default value for this variable is
      `/opt/hpx` (Linux), or `C:/Program Files/hpx` (Windows).]
    ]
    [[`CMAKE_C_FLAGS:STRING`]
     [Extra flags to use when compiling C source files.]
    ]
    [[`CMAKE_CXX_FLAGS:STRING`]
     [Extra flags to use when compiling C++ source files.]
    ]
    [[`CMAKE_FORTRAN_FLAGS:STRING`]
     [Extra flags to use when compiling Fortran source files.]
    ]
    [[`CMAKE_VERBOSE_MAKEFILE:BOOL`]
     [Create verbose makefiles if `ON` (default: `OFF`). CMake will produce
      verbose makefiles that show each command line as it is used.]
    ]
]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:hpx_variables HPX specific CMake Variables]

Here are listed the most frequently used CMake variables specific to __hpx__,
along with a brief explanation.

[variablelist Frequently used HPX specific CMake Variables
    [[`HPX_BUILD_DOCUMENTATION:BOOL`]
     [Build the __hpx__ documentation if the documentation toolchain is available
      (default: `OFF`). For more information about how to set up the documentation
      tool chain please refer to the section __cmake_doc_tools__.]
    ]
    [[`HPX_BUILD_EXAMPLES:BOOL`]
     [__hpx__ examples will be built (default: `ON`). To actually build the
      examples execute `make examples`.]
    ]
    [[`HPX_BUILD_TESTS:BOOL`]
     [__hpx__ tests will be built (default: `ON`). To actually build
      the tests execute `make tests`.]
    ]
    [[`HPX_CMAKE_LOGLEVEL:STRING`]
     [Sets the debugging level for the __hpx__ build system generation. Possible
      values are `Error`, `Warn`, `Debug`, and `Info`. The default is `Warn`.]
    ]
    [[`HPX_NO_LOGGING:BOOL`]
     [Sets whether __hpx__ should not support generating detailed logging output
      (default: `OFF`). Even if this is set to `OFF` (i.e. logging is supported)
      you need to enable logging when running any __hpx__ application. Logging
      support introducied a minimal runtime overhead which usually can be ignored.
      This option allows to remove this runtime overhead but by doing so disables
      the capability to extract detailed runtime information in case of errors.]
    ]
    [[`HPX_HAVE_CXX11:BOOL`]
     [Sets whether __hpx__ should use C++11 support, if available (default: `ON`).]
    ]
    [[`HPX_HAVE_STACKTRACES:BOOL`]
     [Sets whether __hpx__ applications should support capturing stack back-
      traces (default: `ON`).]
    ]
    [[`HPX_HAVE_NATIVE_TLS:BOOL`]
     [Sets whether __hpx__ should use the native compiler support for thread
      local storage, if available (default: `ON`).]
    ]
    [[`HPX_THREAD_DEBUG_INFO:BOOL`]
     [Sets whether __hpx__ threads should maintain detailed debugging information
      like the parent thread id, the phase execution count, the thread description,
      and the LCO description (while the thread is suspended). The default value
      for this variable is `OFF` if `CMAKE_BUILD_TYPE=Release` and `ON` otherwise.]
    ]
]

Here is a more complete list of CMake variables specific to __hpx__. These
variables are used more seldom and are mainly useful for debugging purposes.

[variablelist Other HPX specific CMake Variables
    [[`HPX_THREAD_MAINTAIN_BACKTRACE_ON_SUSPENSION:BOOL`]
     [Sets whether __hpx__ threads should capture the stack back-trace whenever
      they are about to be suspended (default: `OFF`).]
    ]
    [[`HPX_THREAD_BACKTRACE_ON_SUSPENSION_DEPTH:STRING`]
     [Sets the depth of the stack back-traces captured during thread suspension
      (default: `5`).]
    ]
    [[`HPX_USE_ITT_NOTIFY:BOOL`]
     [Sets whether __hpx__ supports integration with the diagnostic tools of 
      the Intel Parallel Studio (Intel Amplifier and Intel Inspector). The default
      value for this variable is `OFF`. Even if the variable is set to `ON` 
      you must separately enable integration with the Intel tools at runtime.
      This option is available only if the include files and libraries for
      one of the Intel tools canbe located (see CMake variable `AMPLIFIER`
      below).]
    ]
    [[`HPX_AUTOMATIC_PREPROCESSING:BOOL`]
     [Sets whether the generated makefiles should allow to regenerate the 
      partially preprocessed files that are part of __hpx__. The default value 
      for this option is `OFF`. This option can be enabled only if the 
      __boost_wave__ tool is available (see CMake variable `BOOSTWAVE` below).]
    ]
]

Here is a list of additional libraries and tools which are either optionally 
supported by the build system or are optionally required for certain examples 
or tests. These libraries and tools can be detected by the __hpx__ build 
system.

Each of the tools or libraries listed here will be automatically detected if 
they are installed in some standard location. If a tool or library is installed 
in a different location you can specify its base directory by appending `_ROOT`
to the variable name as listed below. For instance, to configure a custom
directory for `BOOST`, specify `BOOST_ROOT=/custom/boost/root`.

[variablelist Additional Tools and Libraries
    [[`BOOST:PATH`]
     []
    ]
    [[`BOOSTWAVE:PATH`]
     []
    ]
    [[`HDF5:PATH`]
     []
    ]
    [[`HWLOC:PATH`]
     []
    ]
    [[`MPI:PATH`]
     []
    ]
    [[`MPIEXEC:PATH`]
     []
    ]
    [[`PAPI:PATH`]
     []
    ]
    [[`AMPLIFIER:PATH`]
     []
    ]
]


[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:doc_tools Setting up the HPX Documentation Tool Chain]

[variablelist CMake Variables needed for the Documentation Toolchain
    [[`DOCBOOK_DTD:PATH`]
     []
    ]
    [[`DOCBOOK_XSL:PATH`]
     []
    ]
    [[`DOXYGEN:PATH`]
     []
    ]
    [[`QUICKBOOK:PATH`]
     []
    ]
    [[`XSLTPROC:PATH`]
     []
    ]
]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:unix_apps_pkg_config How to Build __hpx__ Applications with pkg-config]

After you are done installing __hpx__, you should be able to build the following
program. It prints [^Hello HPX World!] on the locality you run it on.

[c++]

[import ../../examples/quickstart/simplest_hello_world.cpp]

[simplest_hello_world_getting_started]

Copy the text of this program into a file called hello_world.cpp.

Now, in the directory where you put hello_world.cpp, issue the following commands
(where [^$HPX_LOCATION] is the [^CMAKE_INSTALL_PREFIX] you used while building __hpx__):

[teletype]

``
    $ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HPX_LOCATION/lib/pkgconfig
    $ c++ -o hello_world hello_world.cpp `pkg-config --cflags --libs hpx_application` -liostreams -DHPX_APPLICATION_NAME=hello_world
``

[important When using pkg-config with __hpx__, the pkg-config flags must go after
           the [^-o] flag.]

[note If HPX was build in debug mode (`cmake -DCMAKE_BUILD_TYPE=Debug`) the 
      pkg-config names have to be different. Instead of `hpx_application` or 
      `hpx_component` you will have to use `hpx_application_debug` or 
      `hpx_component_debug`. Moreover, all referenced HPX components need to 
      have a appended 'd' suffix, e.g. instead of `-liostreams` you will need
      to specify `-liostreamsd`.]

To test the program, type:

``
    $ ./hello_world
``

which should print [^Hello HPX World!] and exit.

[endsect] [/ How to Build __hpx__ Applications with pkg-config]

[/////////////////////////////////////////////////////////////////////////////]
[section:unix_comps_pkg_config How to Build __hpx__ Components with pkg-config]

Let's try a more complex example involving an __hpx__ component. An __hpx__ component is
a class which exposes __hpx__ actions. __hpx__ components are compiled into dynamically
loaded modules called component libraries. Here's the source code:

[c++]

[import ../../examples/hello_world_component/hello_world_component.hpp]

[*hello_world_component.cpp]

[import ../../examples/hello_world_component/hello_world_component.cpp]

[hello_world_cpp_getting_started]

[*hello_world_component.hpp]

[hello_world_hpp_getting_started]

[*hello_world_client.cpp]

[import ../../examples/hello_world_component/hello_world_client.cpp]

[hello_world_client_getting_started]

Copy the three source files above into three files (called hello_world_component.cpp,
hello_world_component.hpp and hello_world_client.cpp respectively).

Now, in the directory where you put the files, run the following command to
build the component library. (where [^$HPX_LOCATION] is the
[^CMAKE_INSTALL_PREFIX] you used while building __hpx__):

[teletype]

``
    $ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HPX_LOCATION/lib/pkgconfig
    $ c++ -o libhello_world.so hello_world_component.cpp `pkg-config --cflags --libs hpx_component` -DHPX_COMPONENT_NAME=hello_world
``

Now pick a directory in which to install your hpx component libraries. For
this example, we'll choose a directory named ''my_hpx_libs''.

``
    $ mkdir ~/my_hpx_libs
    $ mv libhello_world.so ~/my_hpx_libs
``

[note If HPX was build in debug mode (`cmake -DCMAKE_BUILD_TYPE=Debug`) the 
      pkg-config names have to be different. Instead of `hpx_application` or 
      `hpx_component` you will have to use `hpx_application_debug` or 
      `hpx_component_debug`. Moreover, all referenced HPX components need to 
      have a appended 'd' suffix, e.g. instead of `-liostreams` you will need
      to specify `-liostreamsd`.]

In the ~/my_hpx_libs directory you need to create an ini file inside that directory which matches
the name of the component (as supplied by -DHPX_COMPONENT_NAME above).

[*hello_world.ini]
``
    [hpx.components.hello_world]
    name = hello_world
    path = ${HOME}/my_hpx_libs
``

[note For additional details about ini file configuration and __hpx__, see 
      [link hpx.manual.init.configuration.loading_ini_files Loading INI Files]]

In addition, you'll need this in your home directory:

[*.hpx.ini]
``
    [hpx]
    ini_path = $[hpx.ini_path]:${HOME}/my_hpx_libs
``

Now, to build the application that uses this component (hello_world_client.cpp),
we do:

``
    $ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HPX_LOCATION/lib/pkgconfig
    $ c++ -o hello_world_client hello_world_client.cpp `pkg-config --cflags --libs hpx_application` -liostreams -lhello_world
``

[important When using pkg-config with __hpx__, the pkg-config flags must go after
           the [^-o] flag.]


Finally, you'll need to set your LD_LIBRARY_PATH before you can run the program.
To run the program, type:

``
    $ export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$HOME/my_hpx_libs"
    $ ./hello_world_client
``

which should print [^Hello HPX World!] and exit.

[endsect] [/ How to Build __hpx__ Components with pkg-config]

[/////////////////////////////////////////////////////////////////////////////]
[section:existing_apps How to Use __hpx__ with CMake]

[/
Having your application work with __hpx__ is unfortunately not as simple as just
linking against it. However it can be rather straightforward or rather complex
based on the type of application that is trying to be integrated. The complexity
derives from the overall design of the application. If the application was
designed to be parallel, then integrating should be relatively straightforward.
However __hpx__ is not some magic wand that will make your application work in
parallel. Applications that are serial or that rely too heavily on global
variables will have a more difficult time in integrating. Most parallel
applications have already identified the sections of code that do the most
work and have abstracted them out to use the parallel library of their choice.

One of the big advantages of __hpx__ is the concept of moving work to data.
Data-heavy applications can use components to create remote objects that
encapsulate that data, and call methods on these component-objects.
Computation-heavy applications do not care so much about moving work to data,
but instead try to get as much parallel computation done as possible. __hpx__
futures provide a nice tool for accomplishing this. Using futures, one can
set up a lot of work to be done, fire it off and wait for them to be finished.
__hpx__ takes care of creating the threads, moving the work across node
boundaries, and making sure the calling thread suspends when it wants the
value from a future that is still executing. A lot of boring code that you do not
need to write. The one caveat is that for any function you wrap with a
future, any parameters of those functions need to be serializable. This can be
a rather complicated procedure if the data structures are complex.
__hpx__ uses __boost_serialization__ for the serialization of the data to be
used in futures. That really is the hardest part, because once the serialization
functions are completed, you can use futures anywhere in your code. If you
plan on only running on an SMP machine, then __hpx__ never calls the
serialization functions and they may be blank (but the signatures are still
required).

The next stumbling block to integrating __hpx__ is having it actually link
against your program. If your application uses a CMake build system, you can
set the CMake Module Path to the path where __hpx__ has the `FindHPX.cmake`
module. Here is a code snippet demonstrating this.
/]

In Addition to the pkg-config support discussed on the previous pages, __hpx__
comes with full CMake support. In order to integrate __hpx__ into your existing,
or new CMakeLists.txt you can include `FindHPX.cmake`. Following is the Hello
World component example using CMake instead of pkg-config.

Let's revisit what we have. We have three files which compose our example
application:

* `hello_world_component.hpp`
* `hello_world_component.cpp`
* `hello_world_client.hpp`

The basic structure to include __hpx__ into your CMakeLists.txt is shown here:
[teletype]
``
    # Require a recent version of cmake
    cmake_minimum_required(VERSION 2.8.4 FATAL_ERROR)

    # This project is C++ based.
    project(your_app CXX)

    # This adds the HPX cmake configuration directory to the search path.
    set(CMAKE_MODULE_PATH
        ${HPX_ROOT}/share/cmake-${CMAKE_VERSION_MAJOR}.${CMAKE_VERSION_MINOR}/Modules)

    # Instruct cmake to find the HPX settings
    find_package(HPX)

    include_directories(${HPX_INCLUDE_DIR})
    link_directories(${HPX_LIBRARY_DIR})
``

This cmake script assumes that the location of the HPX installation is set 
as the value of HPX_ROOT which is best done by passing it on the command line 
while invoking cmake:

``
    cmake -DHPX_ROOT=<HPX installations directory> ...
``

Alternatively, if you wish to require HPX for your project, replace the
`find_package(HPX)` line with `find_package(HPX REQUIRED)`.

The last two lines in the snippet above sets the appropriate include and link
directories.

In order to add the __hpx__ component we use the `add_hpx_component` macro and
add it to the `CMakeLists.txt` file:

``
    # build your application using HPX
    add_hpx_component(hello_world_component
        ESSENTIAL
        SOURCES hello_world_component.cpp
        HEADERS hello_world_component.hpp
        COMPONENT_DEPENDENCIES iostreams)
``

The available options to `add_hpx_component` are:

* `SOURCES`: The source files for that component
* `HEADERS`: The header files for that component
* `DEPENDENCIES`: Other libraries or targets this component depends on
* `COMPONENT_DEPENDENCIES`: The components this component depends on
* `COMPILE_FLAGS`: Additional compiler flags
* `LINK_FLAGS`: Additional linker flags
[/ `INI`:
* `FOLDER`: Add the headers and source files to this Source Group folder
* `SOURCE_ROOT`:
* `HEADER_ROOT`:
* `SOURCE_GLOB`:
* `HEADER_GLOB`:
* `OUTPUT_SUFFIX`:
* `INSTALL_SUFFIX`:
]
* `ESSENTIAL`: Build this component as part of the `all` target
[/
* `LANGUAGE`:
]

After adding the component, the way you add the executable is as follows:

``
    # build your application using HPX
    add_hpx_executable(hello_world
        ESSENTIAL
        SOURCES hello_world_client.cpp
        COMPONENT_DEPENDENCIES hello_world_component)
``

When you configure your application, all you need to do is set the
HPX_ROOT variable to point to the installation of __hpx__!
[/
Now all you
have to do is type `make` and the application should build using the __hpx__
installation you specified.
]

[note
    `FindHPX.cmake` makes adjustments various cmake internal settings such as
    compiler and linker flags. This is needed to ensure maximal compatibility
    between your application and the __hpx__ version you are using.
    The `add_hpx_executable` and `add_hpx_component` additionally add the proper
    libraries to link against.
]

[c++]
If you do not use CMake, you can still build against __hpx__ but you should refer
to the section on __pkg_config__.

[/
Those two things, the serialization and actually integrating with __hpx__,
are the biggest stumbling blocks that you should encountered when trying to
integrate your application with __hpx__. For an idea on how to integrate __hpx__
constructs into your application, you should take a look at some of the examples
that __hpx__ includes.
]

[endsect] [/ Integrating __hpx__ into existing applications]

[endsect] [/ Building __hpx__ with CMake]

