// Copyright (c) 2007-2013 Hartmut Kaiser
// Copyright (c) 2012-2013 Thomas Heller
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// This file has been automatically generated using the Boost.Wave tool.
// Do not edit manually.


namespace hpx
{
    
    
    
    template <typename F>
    typename boost::lazy_enable_if<
        traits::is_callable<F>
      , detail::create_future<F()>
    >::type
    async (BOOST_SCOPED_ENUM(launch) policy, BOOST_FWD_REF(F) f)
    {
        typedef typename boost::result_of<F()>::type result_type;
        if (policy == launch::sync)
        {
            typedef typename boost::is_void<result_type>::type predicate;
            return detail::call_sync(boost::forward<F>(f), predicate());
        }
        lcos::local::futures_factory<result_type()> p(
            boost::forward<F>(f));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <typename F>
    typename boost::lazy_enable_if<
        traits::is_callable<F>
      , detail::create_future<F()>
    >::type
    async (threads::executor sched, BOOST_FWD_REF(F) f)
    {
        typedef typename boost::result_of<F()>::type result_type;
        lcos::local::futures_factory<result_type()> p(sched,
            boost::forward<F>(f));
        p.apply();
        return p.get_future();
    }
    template <typename F>
    typename boost::lazy_enable_if<
        traits::is_callable<F>
      , detail::create_future<F()>
    >::type
    async (BOOST_FWD_REF(F) f)
    {
        return async(launch::all, boost::forward<F>(f));
    }
    
    
    
    
    
    
    
    
    
    template <typename F, typename A0> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0)> >::type async (BOOST_SCOPED_ENUM(launch) policy, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0) { typedef typename boost::result_of< F(A0) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind(boost::forward<F>(f), boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template <typename F, typename A0> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0)> >::type async (threads::executor sched, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0) { typedef typename boost::result_of<F(A0)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template <typename F, typename A0> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0)> >::type async (BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0) { return async(launch::all, boost::forward<F>(f), boost::forward<A0>( a0 )); } template <typename F, typename A0 , typename A1> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1)> >::type async (BOOST_SCOPED_ENUM(launch) policy, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1) { typedef typename boost::result_of< F(A0 , A1) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1)> >::type async (threads::executor sched, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1) { typedef typename boost::result_of<F(A0 , A1)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1)> >::type async (BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1) { return async(launch::all, boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template <typename F, typename A0 , typename A1 , typename A2> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2)> >::type async (BOOST_SCOPED_ENUM(launch) policy, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2) { typedef typename boost::result_of< F(A0 , A1 , A2) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2)> >::type async (threads::executor sched, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2) { typedef typename boost::result_of<F(A0 , A1 , A2)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2)> >::type async (BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2) { return async(launch::all, boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3)> >::type async (BOOST_SCOPED_ENUM(launch) policy, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3)> >::type async (threads::executor sched, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3)> >::type async (BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3) { return async(launch::all, boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3 , typename A4> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3 , A4)> >::type async (BOOST_SCOPED_ENUM(launch) policy, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3 , typename A4> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3 , A4)> >::type async (threads::executor sched, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3 , typename A4> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3 , A4)> >::type async (BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4) { return async(launch::all, boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3 , A4 , A5)> >::type async (BOOST_SCOPED_ENUM(launch) policy, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3 , A4 , A5)> >::type async (threads::executor sched, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3 , A4 , A5)> >::type async (BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5) { return async(launch::all, boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3 , A4 , A5 , A6)> >::type async (BOOST_SCOPED_ENUM(launch) policy, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3 , A4 , A5 , A6)> >::type async (threads::executor sched, BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5 , A6)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind(boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template <typename F, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6> typename boost::lazy_enable_if< traits::is_callable<F> , detail::create_future<F(A0 , A1 , A2 , A3 , A4 , A5 , A6)> >::type async (BOOST_FWD_REF(F) f, BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6) { return async(launch::all, boost::forward<F>(f), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
}
namespace hpx
{
    
    
    
    template <
        typename R
      , typename T0
      , typename Arg0
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function1<
                R
              , T0
              , Arg0
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0
      , typename Arg0
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function1<
                R
              , T0
              , Arg0
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0
      , typename Arg0
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function1<
                R
              , T0
              , Arg0
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename T0 , typename Arg0 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function1< R , T0 , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename R
      , typename C
      
            
      , typename Arg0
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function1<
                R
              , C
              
                    
              , Arg0
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      
            
      , typename Arg0
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function1<
                R
              , C
              
                    
              , Arg0
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      
            
      , typename Arg0
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function1<
                R
              , C
              
                    
              , Arg0
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename C , typename Arg0 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function1< R , C , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename F
      , typename Arg0
    >
    typename detail::create_future<F(Arg0)>::type
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor1<
                F
              , Arg0
            >
        ))) bound)
    {
        typedef typename boost::result_of<
            F(Arg0)
        >::type result_type;
        if (policy == launch::sync) {
            typedef typename boost::is_void<result_type>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<result_type()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0
    >
    typename detail::create_future<F(Arg0)>::type
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor1<
                F
              , Arg0
            >
        ))) bound)
    {
        typedef typename 
            boost::result_of<F(A0)>::type 
        result_type;
        lcos::local::futures_factory<result_type()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0
    >
    typename detail::create_future<F(Arg0)>::type
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor1<
                F
              , Arg0
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename F , typename Arg0 , typename A0 > typename detail::create_future< F(A0) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of< F(A0) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 > typename detail::create_future< F(A0) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of<F(A0)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 > typename detail::create_future< F(A0) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename F , typename Arg0 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of< F(A0 , A1) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of<F(A0 , A1)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of< F(A0 , A1 , A2) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of<F(A0 , A1 , A2)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5 , A6)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor1< F , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename Action
      , typename Arg0
    >
    lcos::future<
        typename hpx::util::detail::bound_action1<
            Action
          , Arg0
        >::result_type
    >
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action1<
                Action
              , Arg0
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0
    >
    lcos::future<
        typename hpx::util::detail::bound_action1<
            Action
          , Arg0
        >::result_type
    >
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action1<
                Action
              , Arg0
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0
    >
    lcos::future<
        typename hpx::util::detail::bound_action1<
            Action
          , Arg0
        >::result_type
    >
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action1<
                Action
              , Arg0
            >))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename Action , typename Arg0 , typename A0 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename A0 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename A0 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action1< Action , Arg0 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action1< Action , Arg0 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
}
namespace hpx
{
    
    
    
    template <
        typename R
      , typename T0 , typename T1
      , typename Arg0 , typename Arg1
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function2<
                R
              , T0 , T1
              , Arg0 , Arg1
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0 , typename T1
      , typename Arg0 , typename Arg1
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function2<
                R
              , T0 , T1
              , Arg0 , Arg1
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0 , typename T1
      , typename Arg0 , typename Arg1
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function2<
                R
              , T0 , T1
              , Arg0 , Arg1
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function2< R , T0 , T1 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename R
      , typename C
      ,
            typename T0
      , typename Arg0 , typename Arg1
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function2<
                R
              , C
              ,
                    T0
              , Arg0 , Arg1
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      ,
            typename T0
      , typename Arg0 , typename Arg1
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function2<
                R
              , C
              ,
                    T0
              , Arg0 , Arg1
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      ,
            typename T0
      , typename Arg0 , typename Arg1
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function2<
                R
              , C
              ,
                    T0
              , Arg0 , Arg1
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function2< R , C , T0 , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename F
      , typename Arg0 , typename Arg1
    >
    typename detail::create_future<F(Arg0 , Arg1)>::type
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor2<
                F
              , Arg0 , Arg1
            >
        ))) bound)
    {
        typedef typename boost::result_of<
            F(Arg0 , Arg1)
        >::type result_type;
        if (policy == launch::sync) {
            typedef typename boost::is_void<result_type>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<result_type()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0 , typename Arg1
    >
    typename detail::create_future<F(Arg0 , Arg1)>::type
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor2<
                F
              , Arg0 , Arg1
            >
        ))) bound)
    {
        typedef typename 
            boost::result_of<F(A0 , A1)>::type 
        result_type;
        lcos::local::futures_factory<result_type()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0 , typename Arg1
    >
    typename detail::create_future<F(Arg0 , Arg1)>::type
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor2<
                F
              , Arg0 , Arg1
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename F , typename Arg0 , typename Arg1 , typename A0 > typename detail::create_future< F(A0) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of< F(A0) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 > typename detail::create_future< F(A0) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of<F(A0)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 > typename detail::create_future< F(A0) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of< F(A0 , A1) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of<F(A0 , A1)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of< F(A0 , A1 , A2) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of<F(A0 , A1 , A2)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5 , A6)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor2< F , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename Action
      , typename Arg0 , typename Arg1
    >
    lcos::future<
        typename hpx::util::detail::bound_action2<
            Action
          , Arg0 , Arg1
        >::result_type
    >
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action2<
                Action
              , Arg0 , Arg1
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0 , typename Arg1
    >
    lcos::future<
        typename hpx::util::detail::bound_action2<
            Action
          , Arg0 , Arg1
        >::result_type
    >
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action2<
                Action
              , Arg0 , Arg1
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0 , typename Arg1
    >
    lcos::future<
        typename hpx::util::detail::bound_action2<
            Action
          , Arg0 , Arg1
        >::result_type
    >
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action2<
                Action
              , Arg0 , Arg1
            >))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename Action , typename Arg0 , typename Arg1 , typename A0 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename Arg1 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action2< Action , Arg0 , Arg1 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
}
namespace hpx
{
    
    
    
    template <
        typename R
      , typename T0 , typename T1 , typename T2
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function3<
                R
              , T0 , T1 , T2
              , Arg0 , Arg1 , Arg2
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0 , typename T1 , typename T2
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function3<
                R
              , T0 , T1 , T2
              , Arg0 , Arg1 , Arg2
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0 , typename T1 , typename T2
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function3<
                R
              , T0 , T1 , T2
              , Arg0 , Arg1 , Arg2
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function3< R , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename R
      , typename C
      ,
            typename T0 , typename T1
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function3<
                R
              , C
              ,
                    T0 , T1
              , Arg0 , Arg1 , Arg2
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      ,
            typename T0 , typename T1
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function3<
                R
              , C
              ,
                    T0 , T1
              , Arg0 , Arg1 , Arg2
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      ,
            typename T0 , typename T1
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function3<
                R
              , C
              ,
                    T0 , T1
              , Arg0 , Arg1 , Arg2
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function3< R , C , T0 , T1 , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename F
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    typename detail::create_future<F(Arg0 , Arg1 , Arg2)>::type
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor3<
                F
              , Arg0 , Arg1 , Arg2
            >
        ))) bound)
    {
        typedef typename boost::result_of<
            F(Arg0 , Arg1 , Arg2)
        >::type result_type;
        if (policy == launch::sync) {
            typedef typename boost::is_void<result_type>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<result_type()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    typename detail::create_future<F(Arg0 , Arg1 , Arg2)>::type
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor3<
                F
              , Arg0 , Arg1 , Arg2
            >
        ))) bound)
    {
        typedef typename 
            boost::result_of<F(A0 , A1 , A2)>::type 
        result_type;
        lcos::local::futures_factory<result_type()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    typename detail::create_future<F(Arg0 , Arg1 , Arg2)>::type
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor3<
                F
              , Arg0 , Arg1 , Arg2
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > typename detail::create_future< F(A0) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of< F(A0) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > typename detail::create_future< F(A0) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of<F(A0)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > typename detail::create_future< F(A0) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of< F(A0 , A1) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of<F(A0 , A1)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of< F(A0 , A1 , A2) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of<F(A0 , A1 , A2)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5 , A6)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor3< F , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename Action
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    lcos::future<
        typename hpx::util::detail::bound_action3<
            Action
          , Arg0 , Arg1 , Arg2
        >::result_type
    >
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action3<
                Action
              , Arg0 , Arg1 , Arg2
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    lcos::future<
        typename hpx::util::detail::bound_action3<
            Action
          , Arg0 , Arg1 , Arg2
        >::result_type
    >
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action3<
                Action
              , Arg0 , Arg1 , Arg2
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0 , typename Arg1 , typename Arg2
    >
    lcos::future<
        typename hpx::util::detail::bound_action3<
            Action
          , Arg0 , Arg1 , Arg2
        >::result_type
    >
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action3<
                Action
              , Arg0 , Arg1 , Arg2
            >))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action3< Action , Arg0 , Arg1 , Arg2 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
}
namespace hpx
{
    
    
    
    template <
        typename R
      , typename T0 , typename T1 , typename T2 , typename T3
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function4<
                R
              , T0 , T1 , T2 , T3
              , Arg0 , Arg1 , Arg2 , Arg3
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0 , typename T1 , typename T2 , typename T3
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function4<
                R
              , T0 , T1 , T2 , T3
              , Arg0 , Arg1 , Arg2 , Arg3
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0 , typename T1 , typename T2 , typename T3
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function4<
                R
              , T0 , T1 , T2 , T3
              , Arg0 , Arg1 , Arg2 , Arg3
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function4< R , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename R
      , typename C
      ,
            typename T0 , typename T1 , typename T2
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function4<
                R
              , C
              ,
                    T0 , T1 , T2
              , Arg0 , Arg1 , Arg2 , Arg3
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      ,
            typename T0 , typename T1 , typename T2
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function4<
                R
              , C
              ,
                    T0 , T1 , T2
              , Arg0 , Arg1 , Arg2 , Arg3
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      ,
            typename T0 , typename T1 , typename T2
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function4<
                R
              , C
              ,
                    T0 , T1 , T2
              , Arg0 , Arg1 , Arg2 , Arg3
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function4< R , C , T0 , T1 , T2 , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename F
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    typename detail::create_future<F(Arg0 , Arg1 , Arg2 , Arg3)>::type
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor4<
                F
              , Arg0 , Arg1 , Arg2 , Arg3
            >
        ))) bound)
    {
        typedef typename boost::result_of<
            F(Arg0 , Arg1 , Arg2 , Arg3)
        >::type result_type;
        if (policy == launch::sync) {
            typedef typename boost::is_void<result_type>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<result_type()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    typename detail::create_future<F(Arg0 , Arg1 , Arg2 , Arg3)>::type
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor4<
                F
              , Arg0 , Arg1 , Arg2 , Arg3
            >
        ))) bound)
    {
        typedef typename 
            boost::result_of<F(A0 , A1 , A2 , A3)>::type 
        result_type;
        lcos::local::futures_factory<result_type()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    typename detail::create_future<F(Arg0 , Arg1 , Arg2 , Arg3)>::type
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor4<
                F
              , Arg0 , Arg1 , Arg2 , Arg3
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > typename detail::create_future< F(A0) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of< F(A0) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > typename detail::create_future< F(A0) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of<F(A0)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > typename detail::create_future< F(A0) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of< F(A0 , A1) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of<F(A0 , A1)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of< F(A0 , A1 , A2) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of<F(A0 , A1 , A2)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5 , A6)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor4< F , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename Action
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    lcos::future<
        typename hpx::util::detail::bound_action4<
            Action
          , Arg0 , Arg1 , Arg2 , Arg3
        >::result_type
    >
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action4<
                Action
              , Arg0 , Arg1 , Arg2 , Arg3
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    lcos::future<
        typename hpx::util::detail::bound_action4<
            Action
          , Arg0 , Arg1 , Arg2 , Arg3
        >::result_type
    >
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action4<
                Action
              , Arg0 , Arg1 , Arg2 , Arg3
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3
    >
    lcos::future<
        typename hpx::util::detail::bound_action4<
            Action
          , Arg0 , Arg1 , Arg2 , Arg3
        >::result_type
    >
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action4<
                Action
              , Arg0 , Arg1 , Arg2 , Arg3
            >))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action4< Action , Arg0 , Arg1 , Arg2 , Arg3 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
}
namespace hpx
{
    
    
    
    template <
        typename R
      , typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function5<
                R
              , T0 , T1 , T2 , T3 , T4
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function5<
                R
              , T0 , T1 , T2 , T3 , T4
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_function5<
                R
              , T0 , T1 , T2 , T3 , T4
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_function5< R , T0 , T1 , T2 , T3 , T4 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename R
      , typename C
      ,
            typename T0 , typename T1 , typename T2 , typename T3
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    lcos::future<R>
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function5<
                R
              , C
              ,
                    T0 , T1 , T2 , T3
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >
        ))) bound)
    {
        if (policy == launch::sync) {
            typedef typename boost::is_void<R>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<R()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      ,
            typename T0 , typename T1 , typename T2 , typename T3
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    lcos::future<R>
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function5<
                R
              , C
              ,
                    T0 , T1 , T2 , T3
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >
        ))) bound)
    {
        lcos::local::futures_factory<R()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename R
      , typename C
      ,
            typename T0 , typename T1 , typename T2 , typename T3
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    lcos::future<R>
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_member_function5<
                R
              , C
              ,
                    T0 , T1 , T2 , T3
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { if (policy == launch::sync) { typedef typename boost::is_void<R>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<R()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { lcos::local::futures_factory<R()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename R , typename C , typename T0 , typename T1 , typename T2 , typename T3 , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future<R> async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_member_function5< R , C , T0 , T1 , T2 , T3 , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename F
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    typename detail::create_future<F(Arg0 , Arg1 , Arg2 , Arg3 , Arg4)>::type
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor5<
                F
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >
        ))) bound)
    {
        typedef typename boost::result_of<
            F(Arg0 , Arg1 , Arg2 , Arg3 , Arg4)
        >::type result_type;
        if (policy == launch::sync) {
            typedef typename boost::is_void<result_type>::type predicate;
            return detail::call_sync(boost::move(bound), predicate());
        }
        lcos::local::futures_factory<result_type()> p(boost::move(bound));
        if (detail::has_async_policy(policy))
            p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    typename detail::create_future<F(Arg0 , Arg1 , Arg2 , Arg3 , Arg4)>::type
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor5<
                F
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >
        ))) bound)
    {
        typedef typename 
            boost::result_of<F(A0 , A1 , A2 , A3 , A4)>::type 
        result_type;
        lcos::local::futures_factory<result_type()> p(sched, boost::move(bound));
        p.apply();
        return p.get_future();
    }
    template <
        typename F
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    typename detail::create_future<F(Arg0 , Arg1 , Arg2 , Arg3 , Arg4)>::type
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_functor5<
                F
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >
        ))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > typename detail::create_future< F(A0) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of< F(A0) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > typename detail::create_future< F(A0) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { typedef typename boost::result_of<F(A0)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > typename detail::create_future< F(A0) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of< F(A0 , A1) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { typedef typename boost::result_of<F(A0 , A1)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > typename detail::create_future< F(A0 , A1) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of< F(A0 , A1 , A2) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { typedef typename boost::result_of<F(A0 , A1 , A2)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > typename detail::create_future< F(A0 , A1 , A2) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > typename detail::create_future< F(A0 , A1 , A2 , A3) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type result_type; if (policy == launch::sync) { typedef typename boost::is_void<result_type>::type predicate; return detail::call_sync(util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )), predicate()); } lcos::local::futures_factory<result_type()> p( util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); if (detail::has_async_policy(policy)) p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { typedef typename boost::result_of<F(A0 , A1 , A2 , A3 , A4 , A5 , A6)>::type result_type; lcos::local::futures_factory<result_type()> p(sched, util::bind( util::protect(boost::move(bound)) , boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 ))); p.apply(); return p.get_future(); } template < typename F , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > typename detail::create_future< F(A0 , A1 , A2 , A3 , A4 , A5 , A6) >::type async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_functor5< F , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
    
    
    
    template <
        typename Action
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    lcos::future<
        typename hpx::util::detail::bound_action5<
            Action
          , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
        >::result_type
    >
    async(BOOST_SCOPED_ENUM(launch) policy,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action5<
                Action
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    lcos::future<
        typename hpx::util::detail::bound_action5<
            Action
          , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
        >::result_type
    >
    async(threads::executor sched,
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action5<
                Action
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >))) bound)
    {
        return bound.async();
    }
    template <
        typename Action
      , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4
    >
    lcos::future<
        typename hpx::util::detail::bound_action5<
            Action
          , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
        >::result_type
    >
    async(
        BOOST_RV_REF(HPX_UTIL_STRIP((
            hpx::util::detail::bound_action5<
                Action
              , Arg0 , Arg1 , Arg2 , Arg3 , Arg4
            >))) bound)
    {
        return async(launch::all, boost::move(bound));
    }
    
    template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { return bound.async(boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(BOOST_SCOPED_ENUM(launch) policy, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async(threads::executor sched, BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return bound.async(boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); } template < typename Action , typename Arg0 , typename Arg1 , typename Arg2 , typename Arg3 , typename Arg4 , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > lcos::future< typename hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >::result_type > async( BOOST_RV_REF(HPX_UTIL_STRIP(( hpx::util::detail::bound_action5< Action , Arg0 , Arg1 , Arg2 , Arg3 , Arg4 >))) bound , BOOST_FWD_REF(A0) a0 , BOOST_FWD_REF(A1) a1 , BOOST_FWD_REF(A2) a2 , BOOST_FWD_REF(A3) a3 , BOOST_FWD_REF(A4) a4 , BOOST_FWD_REF(A5) a5 , BOOST_FWD_REF(A6) a6 ) { return async(launch::all, boost::move(bound), boost::forward<A0>( a0 ) , boost::forward<A1>( a1 ) , boost::forward<A2>( a2 ) , boost::forward<A3>( a3 ) , boost::forward<A4>( a4 ) , boost::forward<A5>( a5 ) , boost::forward<A6>( a6 )); }
}
