//  Copyright (c) 2007-2008 Hartmut Kaiser
//
//  Distributed under the Boost Software License, Version 1.0. (See accompanying 
//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

#if !defined(HPX_NAMING_CLIENT_RESOLVER_MAR_24_2008_0952AM)
#define HPX_NAMING_CLIENT_RESOLVER_MAR_24_2008_0952AM

#include <boost/asio.hpp>

#include <hpx/config.hpp>
#include <hpx/naming/name.hpp>
#include <hpx/naming/address.hpp>

///////////////////////////////////////////////////////////////////////////////
namespace hpx { namespace naming 
{
    namespace server
    {
        class reply;
        class request;
    }
        
    /// The top-level class of the DGAS client. This class exposes the DGAS 
    /// server functionality on the client side.
    class resolver_client
    {
    public:
        /// Construct the resolver client to work with the server given by
        /// a locality
        explicit resolver_client(locality l);
        
        /// Construct the resolver client to work with the server given by
        /// its address and port number.
        resolver_client(std::string const& address, unsigned short port);

        /// Get unique prefix usable as locality id (locality prefix)
        ///
        /// Every locality needs to have an unique locality id, which may be 
        /// used to issue unique global ids without having to consult the PGAS
        /// server for every id to generate.
        /// 
        /// locality l:       [in] The locality the locality id needs to be 
        ///                   generated for. Repeating calls using the same 
        ///                   locality results in identical prefix values.
        /// uint64_t& prefix: [out] The generated prefix value uniquely 
        ///                   identifying the given locality. This is valid 
        ///                   only, if the return value of this function is 
        ///                   true.
        ///
        /// This function returns true if a new prefix has been generated (it 
        /// has been called for the first time for the given locality) and 
        /// returns false if this locality already got a prefix assigned in an 
        /// earlier call. Any error results in an exception thrown from this
        /// function.
        bool get_prefix(locality l, boost::uint64_t& prefix);

        /// Get unique range of freely assignable global ids 
        ///
        /// Every locality needs to be able to assign global ids to different
        /// components without having to consult the DGAS server for every id 
        /// to generate. This function can be called to preallocate a range of
        /// ids usable for this purpose.
        /// 
        /// locality l:       [in] The locality the locality id needs to be 
        ///                   generated for. Repeating calls using the same 
        ///                   locality results in identical prefix values.
        /// uint64_t& lower_bound: 
        ///                   [out] The lower bound of the assigned id range.
        ///                   The returned value can be used as the first id
        ///                   to assign. This is valid only, if the return 
        ///                   value of this function is true.
        /// uint64_t& upper_bound: 
        ///                   [out] The upper bound of the assigned id range.
        ///                   The returned value can be used as the last id
        ///                   to assign. This is valid only, if the return 
        ///                   value of this function is true.
        ///
        /// This function returns true if a new range has been generated (it 
        /// has been called for the first time for the given locality) and 
        /// returns false if this locality already got a range assigned in an 
        /// earlier call. Any error results in an exception thrown from this
        /// function.
        bool get_id_range(locality l, boost::uint64_t& lower_bound, 
            boost::uint64_t& upper_bound);
        
        /// Bind a global address to a local address.
        ///
        /// Every element in the ParalleX namespace has a unique global address
        /// (global id). This global id is generated by the function 
        /// px_core::get_next_component_id(). This global address has to be 
        /// associated with a concrete local address to be able to address an
        /// instance of a component using it's global address.
        ///
        /// id_type id:       [in] The global address which has to be bound to 
        ///                   the local address.
        /// address addr:     [in] The local address to be bound to the global 
        ///                   address.
        /// 
        /// This function returns true, if this global id got associated with 
        /// an local address for the first time. It returns false, if the 
        /// global id was associated with another local address earlier and the 
        /// given local address replaced the previously associated local 
        /// address. Any error results in an exception thrown from this
        /// function.
        bool bind(id_type id, address const& addr);
        
        /// Unbind a global address
        ///
        /// Remove the association of the given global address with any local 
        /// address, which was bound to this global address.
        /// 
        /// id_type id:       [in] The global address (id) for which the 
        ///                   association has to be removed.
        ///
        /// The function returns true if the association has been removed, and 
        /// it returns false if no association existed. Any error results in an 
        /// exception thrown from this function.
        bool unbind(id_type id);
        
        /// Resolve a given global address (id) to its associated local address
        ///
        /// This function returns the local address which is currently 
        /// associated with the given global address (id).
        ///
        /// id_type id:       [in] The global address (id) for which the 
        ///                   associated local address should be returned.
        /// address& addr:    [out] The local address which currently is 
        ///                   associated with the given global address (id), 
        ///                   this is valid only if the return value of this 
        ///                   function is true.
        ///
        /// This function returns true if the global address has been resolved
        /// successfully (there exists an association to a local address) and
        /// the associated local address has been returned. The function 
        /// returns false if no association exists for the given global 
        /// address. Any error results in an exception thrown from this
        /// function.
        bool resolve(id_type id, address& addr);

        /// Register a global name with a global address (id)
        /// 
        /// This function registers an association between a global name 
        /// (string) and a global address (id) usable with one of the functions 
        /// above (bind, unbind, and resolve).
        ///
        /// string name:      [in] The global name (string) to be associated
        ///                   with the global address.
        /// id_type id:       [in] The global address (id) to be associated 
        ///                   with the global address.
        /// 
        /// The function returns true if the global name got an association 
        /// with a global address for the first time, and it returns false if
        /// this function call replaced a previously registered global address
        /// with the global address (id) given as the parameter. Any error 
        /// results in an exception thrown from this function.
        bool registerid(std::string const& ns_name, id_type id);

        /// Unregister a global name (release any existing association)
        ///
        /// This function releases any existing association of the given global 
        /// name with a global address (id). 
        /// 
        /// string name:      [in] The global name (string) for which any 
        ///                   association with a global address (id) has to be 
        ///                   released.
        /// 
        /// The function returns true if an association of this global name has 
        /// been released, and it returns false, if no association existed.
        /// Any error results in an exception thrown from this function.
        bool unregisterid(std::string const& ns_name);

        /// Query for the global address associated with a given global name.
        ///
        /// This function returns the global address associated with the given 
        /// global name.
        ///
        /// string name:      [in] The global name (string) for which the 
        ///                   currently associated global address has to be 
        ///                   retrieved.
        /// id_type& id:      [out] The id currently associated with the given 
        ///                   global name (valid only if the return value is 
        ///                   true).
        /// 
        /// This function returns true if it returned global address (id), 
        /// which is currently associated with the given global name, and it 
        /// returns false, if currently there is no association for this global 
        /// name. Any error results in an exception thrown from this function.
        bool queryid(std::string const& ns_name, id_type& id);

        /// Query for the gathered statistics of this DGAS instance 
        ///
        /// This function returns the average timings for each of the commands
        /// 
        /// std::vector<double>& timings
        ///                   [out] A pre-allocated array of double's of the
        ///                   size 'server::command_lastcommand', i.e. one 
        ///                   entry for each of the commands
        bool get_statistics(std::vector<double>& timings);
        
    protected:
        static bool read_completed(boost::system::error_code const& err, 
            std::size_t bytes_transferred, boost::uint32_t size);
        void execute(server::request const& req, server::reply& rep);

    private:
        boost::asio::io_service io_service_;
        boost::asio::ip::tcp::socket socket_;
    };

///////////////////////////////////////////////////////////////////////////////
}}  // namespace hpx::naming

#endif
