// Copyright (c) 2007-2013 Hartmut Kaiser
// Copyright (c) 2012-2013 Thomas Heller
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// This file has been automatically generated using the Boost.Wave tool.
// Do not edit manually.


namespace hpx { namespace util { namespace detail
{
    
    template <typename R, typename A0>
    struct empty_function<R(A0)>
    {
        R operator()(A0) const
        {
            hpx::throw_exception(bad_function_call,
                "empty function object should not be used",
                "empty_function::operator()");
        }
    };
}}}
namespace hpx { namespace util { namespace detail
{
    
    template <typename R, typename A0 , typename A1>
    struct empty_function<R(A0 , A1)>
    {
        R operator()(A0 , A1) const
        {
            hpx::throw_exception(bad_function_call,
                "empty function object should not be used",
                "empty_function::operator()");
        }
    };
}}}
namespace hpx { namespace util { namespace detail
{
    
    template <typename R, typename A0 , typename A1 , typename A2>
    struct empty_function<R(A0 , A1 , A2)>
    {
        R operator()(A0 , A1 , A2) const
        {
            hpx::throw_exception(bad_function_call,
                "empty function object should not be used",
                "empty_function::operator()");
        }
    };
}}}
namespace hpx { namespace util { namespace detail
{
    
    template <typename R, typename A0 , typename A1 , typename A2 , typename A3>
    struct empty_function<R(A0 , A1 , A2 , A3)>
    {
        R operator()(A0 , A1 , A2 , A3) const
        {
            hpx::throw_exception(bad_function_call,
                "empty function object should not be used",
                "empty_function::operator()");
        }
    };
}}}
namespace hpx { namespace util { namespace detail
{
    
    template <typename R, typename A0 , typename A1 , typename A2 , typename A3 , typename A4>
    struct empty_function<R(A0 , A1 , A2 , A3 , A4)>
    {
        R operator()(A0 , A1 , A2 , A3 , A4) const
        {
            hpx::throw_exception(bad_function_call,
                "empty function object should not be used",
                "empty_function::operator()");
        }
    };
}}}
namespace hpx { namespace util { namespace detail
{
    
    template <typename R, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5>
    struct empty_function<R(A0 , A1 , A2 , A3 , A4 , A5)>
    {
        R operator()(A0 , A1 , A2 , A3 , A4 , A5) const
        {
            hpx::throw_exception(bad_function_call,
                "empty function object should not be used",
                "empty_function::operator()");
        }
    };
}}}
namespace hpx { namespace util { namespace detail
{
    
    template <typename R, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6>
    struct empty_function<R(A0 , A1 , A2 , A3 , A4 , A5 , A6)>
    {
        R operator()(A0 , A1 , A2 , A3 , A4 , A5 , A6) const
        {
            hpx::throw_exception(bad_function_call,
                "empty function object should not be used",
                "empty_function::operator()");
        }
    };
}}}
namespace hpx { namespace util { namespace detail
{
    
    template <typename R, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7>
    struct empty_function<R(A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7)>
    {
        R operator()(A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7) const
        {
            hpx::throw_exception(bad_function_call,
                "empty function object should not be used",
                "empty_function::operator()");
        }
    };
}}}
